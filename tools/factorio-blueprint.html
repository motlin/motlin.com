<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Factorio Blueprint Parser</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash/4.17.21/lodash.min.js"></script>
    <style>
        /* Base styles matching Factorio's aesthetic */
        body {
            background-color: #201810;
            color: #fff;
            font-family: 'Titillium Web', sans-serif;
            margin: 0;
            padding: 16px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 16px;
        }

        h1 {
            color: #ffe6c0;
            font-weight: bold;
            font-size: 130%;
            margin-bottom: 12px;
        }

        /* Panel styling based on Factorio's UI */
        .panel {
            background-color: #313031;
            padding: 8px;
            margin: 12px 0;
            border: 4px solid #2e2623;
            box-shadow: 0px 0px 3px 0px #201815;
        }

        .panel-inset {
            background-color: #242324;
            border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAMAAABgOjJdAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kTtIw1AUhv+miiIVBzuICEaoThbEF45ahSJUCLVCqw4mN31Bk4YkxcVRcC04+FisOrg46+rgKgiCDxBHJydFFynx3KTQIsYDl/vx3/P/3HsuINRKTLPaxgBNt81kPCamM6tixysCGEQIQ5iSmWXMSVICvvV1T91Ud1Ge5d/3Z3WrWYsBAZF4lhmmTbxBPL1pG5z3icOsIKvE58SjJl2Q+JHrisdvnPMuCzwzbKaS88RhYjHfwkoLs4KpEU8SR1RNp3wh7bHKeYuzVqqwxj35C0NZfWWZ67QGEMciliBBhIIKiijBRpR2nRQLSTqP+fj7Xb9ELoVcRTByLKAMDbLrB/+D37O1chPjXlIoBrS/OM7HMNCxC9SrjvN97Dj1EyD4DFzpTX+5Bsx8kl5tapEjoGcbuLhuasoecLkD9D0Zsim7UpCWkMsB72f0TRmg9xboWvPm1jjH6QOQolklboCDQ2AkT9nrPu/ubJ3bvz2N+f0As9tywbHNoQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfmAgMLNBNXffN5AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAQtQTFRFAAAAAAAAMTAAYQABMQABAAAA/9y6AAAAAAAA/7F+SjAAMRgAMQABGQABAAAA/9nH/9m0MQ8AIQ8AAAAAAAAA/8GqGQsAAAAAAAAAAAAAAAAAOxwAMRMAJwkAFAkAMQ8AKQ8AEQABAAAAAAAAAAAA/+/pBwYA//fq//HkAAAAJQsAAAAAIQoABQQA//nwIgkADwQAAAAA//XsAAAAAAAAAAAAHQsA//rzAAAAAAAAAAAACgIAAAAAAAAADAUABgIAAAAAAAAAAAAAAAAAGQcADwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAcAAAAACgMAAAAAAAAAAAAACgIAAAAAAAAAAwIAAAAAdNLDhQAAAFh0Uk5TAAIFBQUFBwgJCgoKCwsMDg4QEBASFRUVGBkaGhoaHx8gICEiIyQlJiYqLi8vMjQ0NDY2Nzo+P0FBTE5PUVNTVFpcXmNjZG9wcXJzdHh5fYCChIuMl5utu+r6V5gAAAABYktHRFmasvQYAAABUklEQVR4nLXUyU7DMBAG4PHEaewsbWihUg9IIPH+T4QEEodKhZa0Wew0jo2SLlD74BM+WZpP8nj5TcA3yGWCdkXfCsTIFq3WvwIRYGqLA8BoyAg4jx9t8dEIMZBBUJ7P5itbrHf7QqhRIE4XD0tmC7n53B60HgSF+er+jtpCfX+td6CAAPIoW2YpM1pp3RsAEiBSJLIqN2Ur9FVESnbKnAShIaOtLaiQUvdD84gBMsaVLUhTdY3uBhFiHKaxsYWu5EEK3QMEyNmUpWgLVddV0XVHgEkY5mmSUFscK1FUoh1WiXia83RiC1nX+7LqFQAN0myWJOw/hL8P/1785+E/U/+9+O/W/z7cKF0F0CzOg7UDnt9WfdGUahRJ9v7iCKpen8r6JKKFigNHGNI3dNuqMVEkUtwRxAjaGn1KZUJg4nYKRzD1n2Q79egcbeJULgPP38MP9ZBIMci5WIsAAAAASUVORK5CYII=") 16/8px repeat;
            border-image-outset: 4px;
            padding: 8px;
            margin: 12px 0;
        }

        /* Split view layout */
        .split-view {
            display: flex;
            gap: 16px;
        }

        .split-pane {
            flex: 1;
            min-width: 0;
        }

        /* Blueprint input styling */
        #blueprint-input {
            width: 100%;
            height: 60px;
            background: #8e8e8e;
            border-radius: 4px;
            padding: 6px;
            border: none;
            color: #000;
            font-family: monospace;
            box-shadow: inset 0px 4px 1px -2px #000;
        }

        /* Cards styling */
        .card {
            background-color: #242324;
            margin-bottom: 12px;
            cursor: pointer;
      border: 4px solid #2e2623;
      box-shadow: 0px 0px 3px 0px #201815;
        }

        .card-header {
            padding: 8px;
            color: #ffe6c0;
            font-weight: bold;
      background-color: #313031;
      display: flex;
      align-items: center;
      gap: 8px;
        }

        .card-content {
            padding: 8px;
            display: none;
        }

        .card.expanded .card-content {
            display: block;
      background-color: #242324;
    }

    /* Info grid styling */
    .info-grid {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px;
      align-items: center;
    }

    .info-label {
      color: #7dcaed;
      padding-right: 12px;
    }

    .info-value {
      color: #fff;
    }

    /* Blueprint tree styling */
    .blueprint-tree {
      font-size: 14px;
    }

    .tree-row {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 2px;
      gap: 8px;
    }

    .tree-row:hover {
      background-color: #414040;
    }

    .tree-row.selected {
      background-color: #5eb663;
      color: #000;
    }

    .tree-row.selected:hover {
      background-color: #7ac97e;
    }

    .tree-indent {
      width: 20px;
      flex-shrink: 0;
    }

    .tree-type-icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
    }

    .tree-icons {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    /* JSON card styling */
    .json-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
    }

    .json-display {
        display: none;
        white-space: pre-wrap;
        font-family: monospace;
        background-color: #242324;
        padding: 8px;
        border-radius: 4px;
        color: #ffe6c0;
        margin-top: 8px;
        max-height: 400px;
        overflow: auto;
    }

    .json-display.visible {
        display: block;
    }

    .button {
        background-color: #8e8e8e;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        border: none;
        color: #000;
        font-weight: 600;
        box-shadow: inset 8px 0px 4px -8px #000,
        inset -8px 0px 4px -8px #000,
        inset 0px 8px 4px -8px #e3e3e3,
        inset 0px -6px 4px -8px #818181;
    }

    .button:hover {
        background-color: #e39827;
        box-shadow: inset 8px 0px 4px -8px #000,
        inset -8px 0px 4px -8px #000,
        inset 0px 9px 2px -8px #fff,
        inset 0px -9px 2px -8px #432400;
    }

    .button:active {
        padding-top: 7px;
        padding-bottom: 5px;
        background-color: #f1be64;
        box-shadow: inset 0px 10px 2px -8px #000,
        inset 0px 9px 2px -8px #000;
    }

    /* Parameters styling */
    .parameters-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .parameter-item {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
    }

    .parameter-name {
        color: #7dcaed;
    }

    .parameter-value {
        color: #fff;
    }

    .parameter-description {
        grid-column: span 2;
        color: #a6a6a6;
        font-size: 90%;
    }

    /* Deconstruction planner styling */
    .deconstruction-settings {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .filter-group-header {
        color: #ffe6c0;
        font-weight: bold;
        margin-bottom: 4px;
    }

    .filter-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 2px 4px;
    }

    .filter-item:hover {
        background-color: #414040;
    }

    .filter-item.excluded {
        text-decoration: line-through;
        opacity: 0.7;
    }

    /* Upgrade planner styling */
    .upgrade-mapping {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 4px 0;
    }

    .upgrade-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upgrade-arrow {
      color: #7dcaed;
      font-size: 20px;
    }
    .contents-tables {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .contents-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 1px 2px;
    }

    .contents-table th {
      color: #7dcaed;
      text-align: left;
      padding: 8px;
      font-weight: normal;
      background-color: #242324;
    }

    .contents-table td {
      padding: 4px 8px;
      background-color: #313031;
    }

    .contents-table tr:hover td {
      background-color: #414040;
    }

    .contents-section {
      margin-bottom: 16px;
    }

    .contents-section-header {
      color: #ffe6c0;
      margin-bottom: 8px;
      font-weight: bold;
    }

    .contents-icon {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .contents-icon img {
      height: 24px;
      width: 24px;
    }

    .contents-count {
      font-family: monospace;
      color: #7dcaed;
    }

    /* Blueprint icons styling */
    .blueprint-icons {
      display: flex;
      gap: 4px;
      align-items: center;
      padding: 4px;
    }

    .blueprint-icon {
      width: 32px;
      height: 32px;
      background: #414040;
      padding: 2px;
      border: 1px solid #2e2623;
    }

    /* Feature badges */
    .feature-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .feature-badge {
      background-color: #414040;
      color: #ffe6c0;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 90%;
    }

    .feature-badge.active {
      background-color: #5eb663;
      color: #000;
        }

        .selected {
            background-color: #3f3f3f;
        }

        /* Error display */
        #error {
            color: #ff5555;
            display: none;
            padding: 8px;
            margin: 8px 0;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Factorio Blueprint Parser</h1>

    <div class="panel">
        <textarea id="blueprint-input" placeholder="Paste your blueprint here"></textarea>
        <div id="error" class="panel-inset"></div>
    </div>

    <div class="split-view">
        <!-- Left pane -->
        <div class="split-pane" id="left-pane">
            <div class="card" id="basic-info">
                <div class="card-header">Basic Information</div>
                <div class="card-content"></div>
            </div>

            <div class="card" id="blueprint-tree">
                <div class="card-header">Blueprint Tree</div>
                <div class="card-content"></div>
            </div>
        </div>

        <!-- Right pane -->
        <div class="split-pane" id="right-pane">
            <div class="card" id="summary">
                <div class="card-header">Summary</div>
                <div class="card-content"></div>
            </div>

            <div class="card" id="contents">
                <div class="card-header">Contents</div>
                <div class="card-content"></div>
            </div>

            <div class="card" id="upgrade-planner">
                <div class="card-header">Upgrade Planner</div>
                <div class="card-content"></div>
            </div>

            <div class="card" id="deconstruction-planner">
                <div class="card-header">Deconstruction Planner</div>
                <div class="card-content"></div>
            </div>

            <div class="card" id="parameters">
                <div class="card-header">Parameters</div>
                <div class="card-content"></div>
            </div>

            <div class="card" id="json">
                <div class="card-header">JSON</div>
                <div class="card-content"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // Convert version number to readable format
    function parseVersion(version) {
        if (typeof version !== 'number') return null;

        // Convert to BigInt for precise bitwise operations
        const versionBig = BigInt(version);

        // Extract 16-bit chunks from 64-bit number
        const parts = [
            Number((versionBig >> 48n) & 0xFFFFn),
            Number((versionBig >> 32n) & 0xFFFFn),
            Number((versionBig >> 16n) & 0xFFFFn),
            Number(versionBig & 0xFFFFn)
        ];

        // Remove trailing zeros and join with dots
        while (parts.length > 1 && parts[parts.length - 1] === 0) {
            parts.pop();
        }
        return parts.join('.');
    }

    // Core blueprint parsing functions
    function parseBlueprint(blueprintString) {
        try {
        // Remove the "0" prefix if present
        if (blueprintString.startsWith('0')) {
          blueprintString = blueprintString.substring(1);
        }

        // Decode base64
        const binaryString = atob(blueprintString);

        // Convert binary string to Uint8Array
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        // Decompress using pako (zlib)
        const decompressed = pako.inflate(bytes, { to: 'string' });

        // Parse JSON
        const blueprint = JSON.parse(decompressed);

        // Helper to check for entity usage
        function usesEntity(blueprint, entityName) {
          if (!blueprint.blueprint?.entities) return false;
          return blueprint.blueprint.entities.some(e => e.name === entityName);
        }

        // Add metadata about feature usage
        const metadata = {
          version: parseVersion(blueprint.blueprint?.version),
          type: Object.keys(blueprint)[0], // blueprint, blueprint_book, etc.
          label: blueprint.blueprint?.label || blueprint.blueprint_book?.label,
          description: blueprint.blueprint?.description || blueprint.blueprint_book?.description,
          icons: blueprint.blueprint?.icons || blueprint.blueprint_book?.icons || [],
          usesParameters: false, // TODO: Implement parameter detection
          uses20Features: [
            'curved-rail-a',
            'curved-rail-b',
            'half-diagonal-rail'
          ].some(entity => usesEntity(blueprint, entity)),
          usesSpaceAgeFeatures: false, // TODO: Implement Space Age feature detection
          usesQualityFeatures: false,  // TODO: Implement Quality feature detection
          usesElevatedRails: [
            'elevated-curved-rail-a',
            'elevated-curved-rail-b',
            'elevated-half-diagonal-rail',
            'elevated-straight-rail',
            'rail-ramp',
            'rail-support'
          ].some(entity => usesEntity(blueprint, entity))
        };

        return {
          raw: blueprint,
          metadata
        };

        } catch (error) {
            showError("Failed to parse blueprint: " + error.message);
            return null;
        }
    }

    // UI update functions
    function showError(message) {
        const errorEl = document.getElementById('error');
        errorEl.textContent = message;
        errorEl.style.display = 'block';
    }

    function hideError() {
        document.getElementById('error').style.display = 'none';
    }

    function updateBasicInfo(blueprint) {
      const content = document.querySelector('#basic-info .card-content');
      if (!blueprint) {
        content.innerHTML = '';
        return;
      }

      const { metadata } = blueprint;

      let html = '<div class="info-grid">';

      // Blueprint type
      html += `
        <div class="info-label">Type</div>
        <div class="info-value">${metadata.type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}</div>
      `;

      // Label
      if (metadata.label) {
        html += `
          <div class="info-label">Label</div>
          <div class="info-value">${richTextParser.parseRichText(metadata.label)}</div>
        `;
      }

      // Description
      if (metadata.description) {
        html += `
          <div class="info-label">Description</div>
          <div class="info-value">${richTextParser.parseRichText(metadata.description)}</div>
        `;
      }

      // Game version
      if (metadata.version) {
        html += `
          <div class="info-label">Game Version</div>
          <div class="info-value">${metadata.version}</div>
        `;
      }

      // Icons
      if (metadata.icons && metadata.icons.length > 0) {
        html += `
          <div class="info-label">Icons</div>
          <div class="blueprint-icons">
        `;
        for (const icon of metadata.icons) {
          if (icon.signal) {
            // Default to 'item' type if not specified
            const type = !icon.signal.type ? 'item' :
                        icon.signal.type === 'virtual' ? 'virtual-signal' :
                        icon.signal.type;
            html += richTextParser.createIcon(type, icon.signal.name);
          }
        }
        html += '</div>';
      }

      html += '</div>'; // Close info-grid

      // Feature badges
      html += '<div class="feature-badges">';

      const features = [
        { name: 'Parameters', active: metadata.usesParameters },
        { name: '2.0 Features', active: metadata.uses20Features },
        { name: 'Space Age', active: metadata.usesSpaceAgeFeatures },
        { name: 'Quality', active: metadata.usesQualityFeatures },
        { name: 'Elevated Rails', active: metadata.usesElevatedRails }
      ];

      for (const feature of features) {
        html += `
          <div class="feature-badge ${feature.active ? 'active' : ''}">
            ${feature.name}
          </div>
        `;
      }

      html += '</div>';

      content.innerHTML = html;

      // Expand the card by default when there's content
      document.getElementById('basic-info').classList.add('expanded');
    }

    // Track the currently selected blueprint path
    let selectedBlueprintPath = '';

    function getBlueprintByPath(blueprint, path) {
      if (!path) return blueprint;

      const parts = path.split('.');
      let current = blueprint;

      for (const part of parts) {
        const index = parseInt(part) - 1;
        if (current.blueprint_book && current.blueprint_book.blueprints) {
          current = current.blueprint_book.blueprints[index];
        } else {
          return null;
        }
      }

      return current;
    }

    function createTreeRow(blueprint, path = '', level = 0) {
      const indent = '<div class="tree-indent"></div>'.repeat(level);
      const isSelected = path === selectedBlueprintPath;

      let rowHtml = `
        <div class="tree-row ${isSelected ? 'selected' : ''}" data-path="${path}">
        ${indent}
      `;

      // Add type icon if it's a special type
      if (blueprint.upgrade_planner) {
        rowHtml += `<div class="tree-type-icon">${richTextParser.createIcon('item', 'upgrade-planner')}</div>`;
      } else if (blueprint.deconstruction_planner) {
        rowHtml += `<div class="tree-type-icon">${richTextParser.createIcon('item', 'deconstruction-planner')}</div>`;
      }

      // Add blueprint icons
      const icons = blueprint.blueprint?.icons ||
                   blueprint.blueprint_book?.icons ||
                   blueprint.upgrade_planner?.icons ||
                   blueprint.deconstruction_planner?.icons || [];

      if (icons.length > 0) {
        rowHtml += '<div class="tree-icons">';
        for (const icon of icons) {
          if (icon.signal) {
            const type = !icon.signal.type ? 'item' :
                        icon.signal.type === 'virtual' ? 'virtual-signal' :
                        icon.signal.type;
            rowHtml += richTextParser.createIcon(type, icon.signal.name);
          }
        }
        rowHtml += '</div>';
      }

      // Add label
      const label = blueprint.blueprint?.label ||
                   blueprint.blueprint_book?.label ||
                   blueprint.upgrade_planner?.label ||
                   blueprint.deconstruction_planner?.label ||
                   '(no label)';

      rowHtml += `<div class="tree-label">${richTextParser.parseRichText(label)}</div>`;
      rowHtml += '</div>';

      // Recursively add children if it's a blueprint book
      if (blueprint.blueprint_book?.blueprints) {
        blueprint.blueprint_book.blueprints.forEach((child, index) => {
          const childPath = path ? `${path}.${index + 1}` : `${index + 1}`;
          rowHtml += createTreeRow(child, childPath, level + 1);
        });
      }

      return rowHtml;
    }

    function updateBlueprintTree(blueprint) {
      const content = document.querySelector('#blueprint-tree .card-content');
      if (!blueprint || !blueprint.raw) {
        content.innerHTML = '';
        document.getElementById('blueprint-tree').style.display = 'none';
        return;
      }

      // Only show tree for blueprint books
      if (!blueprint.raw.blueprint_book) {
        document.getElementById('blueprint-tree').style.display = 'none';
        return;
      }

      document.getElementById('blueprint-tree').style.display = 'block';
      content.innerHTML = `<div class="blueprint-tree">${createTreeRow(blueprint.raw)}</div>`;

      // Add click handlers for tree rows
      content.querySelectorAll('.tree-row').forEach(row => {
        row.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent parent rows from also triggering
          const path = row.dataset.path;
          selectedBlueprintPath = path;

          // Update selection visuals
          content.querySelectorAll('.tree-row').forEach(r => {
            r.classList.toggle('selected', r.dataset.path === path);
          });

          // Update the summary card with the selected blueprint
          const selectedBlueprint = getBlueprintByPath(blueprint.raw, path);
          updateSummary({ raw: selectedBlueprint, metadata: blueprint.metadata });
          updateContents({ raw: selectedBlueprint, metadata: blueprint.metadata });
        });
      });

      // Expand the card when there's content
      document.getElementById('blueprint-tree').classList.add('expanded');
    }

    function getBlueprintMetadata(blueprint) {
      if (!blueprint) return null;

      // Helper to check for entity usage
      function usesEntity(blueprint, entityName) {
        if (!blueprint.blueprint?.entities) return false;
        return blueprint.blueprint.entities.some(e => e.name === entityName);
      }

      // Determine the actual blueprint object based on type
      const actualBlueprint = blueprint.blueprint ||
                            blueprint.blueprint_book ||
                            blueprint.upgrade_planner ||
                            blueprint.deconstruction_planner;

      if (!actualBlueprint) return null;

      // Helper to get type name
      function getTypeName(blueprint) {
        if (blueprint.blueprint) return 'Blueprint';
        if (blueprint.blueprint_book) return 'Blueprint Book';
        if (blueprint.upgrade_planner) return 'Upgrade Planner';
        if (blueprint.deconstruction_planner) return 'Deconstruction Planner';
        return 'Unknown Type';
      }

      return {
        type: getTypeName(blueprint),
        label: actualBlueprint.label,
        description: actualBlueprint.description,
        version: actualBlueprint.version,
        icons: actualBlueprint.icons || [],
        snapToGrid: blueprint.blueprint?.snap_to_grid,
        absoluteSnapping: blueprint.blueprint?.absolute_snapping,
        usesParameters: false, // TODO: Implement parameter detection
        uses20Features: [
          'curved-rail-a',
          'curved-rail-b',
          'half-diagonal-rail'
        ].some(entity => usesEntity(blueprint, entity)),
        usesSpaceAgeFeatures: false, // TODO: Implement Space Age feature detection
        usesQualityFeatures: false,  // TODO: Implement Quality feature detection
        usesElevatedRails: [
          'elevated-curved-rail-a',
          'elevated-curved-rail-b',
          'elevated-half-diagonal-rail',
          'elevated-straight-rail',
          'rail-ramp',
          'rail-support'
        ].some(entity => usesEntity(blueprint, entity))
      };
    }

    function updateSummary(blueprint) {
      const content = document.querySelector('#summary .card-content');
      const cardElement = document.getElementById('summary');

      if (!blueprint || !blueprint.raw) {
        content.innerHTML = '';
        cardElement.style.display = 'none';
        return;
      }

      const metadata = getBlueprintMetadata(blueprint.raw);
      if (!metadata) {
        content.innerHTML = '';
        cardElement.style.display = 'none';
        return;
      }

      cardElement.style.display = 'block';

      let html = '<div class="info-grid">';

      // Blueprint type
      html += `
        <div class="info-label">Type</div>
        <div class="info-value">${metadata.type}</div>
      `;

      // Label
      if (metadata.label) {
        html += `
          <div class="info-label">Label</div>
          <div class="info-value">${richTextParser.parseRichText(metadata.label)}</div>
        `;
      }

      // Description
      if (metadata.description) {
        html += `
          <div class="info-label">Description</div>
          <div class="info-value">${richTextParser.parseRichText(metadata.description)}</div>
        `;
      }

      // Game version
      if (metadata.version) {
        html += `
          <div class="info-label">Game Version</div>
          <div class="info-value">${parseVersion(metadata.version)}</div>
        `;
      }

      // Icons
      if (metadata.icons && metadata.icons.length > 0) {
        html += `
          <div class="info-label">Icons</div>
          <div class="blueprint-icons">
        `;
        for (const icon of metadata.icons) {
          if (icon.signal) {
            const type = !icon.signal.type ? 'item' :
                        icon.signal.type === 'virtual' ? 'virtual-signal' :
                        icon.signal.type;
            html += richTextParser.createIcon(type, icon.signal.name);
          }
        }
        html += '</div>';
      }

      // Snap to grid
      if (metadata.snapToGrid !== undefined) {
        html += `
          <div class="info-label">Grid Snapping</div>
          <div class="info-value">${metadata.snapToGrid ? (metadata.absoluteSnapping ? 'Absolute' : 'Relative') : 'None'}</div>
        `;
      }

      html += '</div>'; // Close info-grid

      // Feature badges
      html += '<div class="feature-badges">';

      const features = [
        { name: 'Parameters', active: metadata.usesParameters },
        { name: '2.0 Features', active: metadata.uses20Features },
        { name: 'Space Age', active: metadata.usesSpaceAgeFeatures },
        { name: 'Quality', active: metadata.usesQualityFeatures },
        { name: 'Elevated Rails', active: metadata.usesElevatedRails }
      ];

      for (const feature of features) {
        html += `
          <div class="feature-badge ${feature.active ? 'active' : ''}">
            ${feature.name}
          </div>
        `;
      }

      html += '</div>';

      content.innerHTML = html;
      cardElement.classList.add('expanded');
    }

    function updateContents(blueprint) {
      const content = document.querySelector('#contents .card-content');
      const cardElement = document.getElementById('contents');

      if (!blueprint?.raw?.blueprint) {
        content.innerHTML = '';
        cardElement.style.display = 'none';
        return;
      }

      cardElement.style.display = 'block';

      let html = '<div class="contents-tables">';

      // Entities table
      if (blueprint.raw.blueprint.entities?.length > 0) {
        const entityCounts = {};
        blueprint.raw.blueprint.entities.forEach(entity => {
          entityCounts[entity.name] = (entityCounts[entity.name] || 0) + 1;
        });

        const sortedEntities = Object.entries(entityCounts)
          .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));

        html += `
          <div class="contents-section">
            <div class="contents-section-header">Entities</div>
            <table class="contents-table">
              <thead>
                <tr>
                  <th>Entity</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
        `;

        sortedEntities.forEach(([name, count]) => {
          html += `
            <tr>
              <td class="contents-icon">
                ${richTextParser.createIcon('entity', name)}
                ${name}
              </td>
              <td class="contents-count">${count}</td>
            </tr>
          `;
        });

        html += '</tbody></table></div>';
      }

      // Recipe count from assembling machines, refineries, chemical plants, etc.
      const recipeEntities = blueprint.raw.blueprint.entities?.filter(
        entity => entity.recipe && [
          'assembling-machine-1',
          'assembling-machine-2',
          'assembling-machine-3',
          'chemical-plant',
          'oil-refinery'
        ].some(prefix => entity.name.startsWith(prefix))
      ) || [];

      if (recipeEntities.length > 0) {
        const recipeCounts = {};
        recipeEntities.forEach(entity => {
          recipeCounts[entity.recipe] = (recipeCounts[entity.recipe] || 0) + 1;
        });

        const sortedRecipes = Object.entries(recipeCounts)
          .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));

        html += `
          <div class="contents-section">
            <div class="contents-section-header">Recipes</div>
            <table class="contents-table">
              <thead>
                <tr>
                  <th>Recipe</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
        `;

        sortedRecipes.forEach(([name, count]) => {
          html += `
            <tr>
              <td class="contents-icon">
                ${richTextParser.createIcon('recipe', name)}
                ${name}
              </td>
              <td class="contents-count">${count}</td>
            </tr>
          `;
        });

        html += '</tbody></table></div>';
      }

      // Tiles table
      if (blueprint.raw.blueprint.tiles?.length > 0) {
        const tileCounts = {};
        blueprint.raw.blueprint.tiles.forEach(tile => {
          tileCounts[tile.name] = (tileCounts[tile.name] || 0) + 1;
        });

        const sortedTiles = Object.entries(tileCounts)
          .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));

        html += `
          <div class="contents-section">
            <div class="contents-section-header">Tiles</div>
            <table class="contents-table">
              <thead>
                <tr>
                  <th>Tile</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
        `;

        sortedTiles.forEach(([name, count]) => {
          html += `
            <tr>
              <td class="contents-icon">
                ${richTextParser.createIcon('tile', name)}
                ${name}
              </td>
              <td class="contents-count">${count}</td>
            </tr>
          `;
        });

        html += '</tbody></table></div>';
      }

      html += '</div>'; // Close contents-tables

      content.innerHTML = html;
      cardElement.classList.add('expanded');
    }

    function updateUpgradePlanner(blueprint) {
        const content = document.querySelector('#upgrade-planner .card-content');
        const cardElement = document.getElementById('upgrade-planner');

        if (!blueprint?.raw?.upgrade_planner) {
            content.innerHTML = '';
            cardElement.style.display = 'none';
            return;
        }

        cardElement.style.display = 'block';

      const mappings = blueprint.raw.upgrade_planner.settings?.mappers || [];
        if (mappings.length === 0) {
            content.innerHTML = '<div class="panel-inset">No upgrade mappings defined</div>';
            return;
        }

        let html = '<div class="upgrade-mappings">';

      // Sort mappings by index
      const sortedMappings = [...mappings].sort((a, b) => (a.index || 0) - (b.index || 0));

      sortedMappings.forEach(mapping => {
            let leftIcon, rightIcon;

            // Handle the "from" side
            if (mapping.from) {
                const type = !mapping.from.type ? 'item' :
                    mapping.from.type === 'virtual' ? 'virtual-signal' :
                        mapping.from.type;
                leftIcon = richTextParser.createIcon(type, mapping.from.name);
            }

            // Handle the "to" side
            if (mapping.to) {
                const type = !mapping.to.type ? 'item' :
                    mapping.to.type === 'virtual' ? 'virtual-signal' :
                        mapping.to.type;
                rightIcon = richTextParser.createIcon(type, mapping.to.name);
            }

            html += `
          <div class="upgrade-mapping">
            <div class="upgrade-item">
              ${leftIcon || '<span class="grey">(any)</span>'}
              ${mapping.from?.name || ''}
            </div>
            <div class="upgrade-arrow">‚Üí</div>
            <div class="upgrade-item">
              ${rightIcon || '<span class="grey">(remove)</span>'}
              ${mapping.to?.name || ''}
            </div>
          </div>
        `;
        });

        html += '</div>';
        content.innerHTML = html;
        cardElement.classList.add('expanded');
    }

    function updateDeconstructionPlanner(blueprint) {
        const content = document.querySelector('#deconstruction-planner .card-content');
        const cardElement = document.getElementById('deconstruction-planner');

        if (!blueprint?.raw?.deconstruction_planner) {
            content.innerHTML = '';
            cardElement.style.display = 'none';
            return;
        }

        cardElement.style.display = 'block';

        const settings = blueprint.raw.deconstruction_planner.settings || {};
        let html = '<div class="deconstruction-settings">';

        // Special modes
        if (settings.trees_and_rocks_only) {
            html += `
              <div class="filter-group">
                <div class="filter-group-header">Mode</div>
                <div class="filter-item">Trees and rocks only</div>
              </div>
            `;
        }

        // Tile selection mode
        if (settings.tile_selection_mode !== undefined) {
            const modeNames = {
                2: 'Never deconstruct tiles',
                3: 'Always deconstruct tiles'
            };
            html += `
              <div class="filter-group">
                <div class="filter-group-header">Tile Selection</div>
                <div class="filter-item">${modeNames[settings.tile_selection_mode] || `Mode ${settings.tile_selection_mode}`}</div>
              </div>
            `;
        }

        // Entity filters
        if (settings.entity_filters?.length > 0) {
            const sortedFilters = [...settings.entity_filters].sort((a, b) => (a.index || 0) - (b.index || 0));
            html += `
              <div class="filter-group">
                <div class="filter-group-header">Entity Filters</div>
            `;

            sortedFilters.forEach(filter => {
                html += `
                <div class="filter-item">
                  ${richTextParser.createIcon('entity', filter.name)}
                  ${filter.name}
                </div>
              `;
            });

            html += '</div>';
        }

        if (html === '<div class="deconstruction-settings">') {
            html += '<div class="panel-inset">No specific settings defined</div>';
        }

        html += '</div>';
        content.innerHTML = html;
        cardElement.classList.add('expanded');
    }

    function updateParameters(blueprint) {
        const content = document.querySelector('#parameters .card-content');
        const cardElement = document.getElementById('parameters');

        if (!blueprint?.raw?.blueprint?.parameters) {
            content.innerHTML = '';
            cardElement.style.display = 'none';
            return;
        }

        const parameters = blueprint.raw.blueprint.parameters;
        if (parameters.length === 0) {
            content.innerHTML = '<div class="panel-inset">No parameters defined</div>';
            return;
        }

        cardElement.style.display = 'block';

        let html = '<div class="parameters-list">';

        parameters.forEach(param => {
            html += `<div class="parameter-item">`;

            // Parameter name
            html += `<div class="parameter-name">${param.name}</div>`;

            // Parameter value based on type
            if (param.type === 'id') {
                html += `<div class="parameter-value">ID: ${param.id}</div>`;

                // Show quality condition if present
                if (param['quality-condition']) {
                    const qualityCond = param['quality-condition'];
                    html += `
              <div class="parameter-description">
                Quality must be ${qualityCond.comparator} ${qualityCond.quality}
              </div>
            `;
                }
            } else if (param.type === 'number') {
                html += `<div class="parameter-value">${param.number}</div>`;
            }

            html += '</div>';
        });

        html += '</div>';
        content.innerHTML = html;
        cardElement.classList.add('expanded');

        // Also update metadata to show parameter usage
        blueprint.metadata.usesParameters = true;
    }

    function updateJson(blueprint) {
        const content = document.querySelector('#json .card-content');
        const cardElement = document.getElementById('json');

        if (!blueprint?.raw) {
            content.innerHTML = '';
            cardElement.style.display = 'none';
            return;
        }

        cardElement.style.display = 'block';

        function downloadJson(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateFilename(blueprint, isRoot, path) {
            let label = blueprint.blueprint?.label ||
                blueprint.blueprint_book?.label ||
                blueprint.upgrade_planner?.label ||
                blueprint.deconstruction_planner?.label ||
                'blueprint';

            // Clean the label for use as filename
            label = label.replace(/[^\w\s-]/g, '')
                .trim()
                .replace(/\s+/g, '-');

            if (!isRoot && path) {
                const rootLabel = blueprint.raw.blueprint?.label ||
                    blueprint.raw.blueprint_book?.label ||
                    'blueprint';
                return `${rootLabel}-${path}.json`;
            }

            return `${label}.json`;
        }

        let selectedJson = selectedBlueprintPath ?
            getBlueprintByPath(blueprint.raw, selectedBlueprintPath) :
            blueprint.raw;

        let html = '<div class="json-actions">';

        // Root blueprint actions
        html += `
           <button class="button" id="copy-root">Copy Root Blueprint</button>
           <button class="button" id="view-root">View Root JSON</button>
           <button class="button" id="download-root">Download Root JSON</button>
         `;

        // Selected blueprint actions (only show if different from root)
        if (selectedBlueprintPath) {
            html += `
             <button class="button" id="copy-selected">Copy Selected Blueprint</button>
             <button class="button" id="view-selected">View Selected JSON</button>
             <button class="button" id="download-selected">Download Selected JSON</button>
           `;
        }

        html += '</div>';

        // JSON display areas
        html += `
           <div id="root-json" class="json-display"></div>
           <div id="selected-json" class="json-display"></div>
         `;

        content.innerHTML = html;

        // Add event listeners
        content.querySelector('#copy-root').addEventListener('click', () => {
            navigator.clipboard.writeText(JSON.stringify(blueprint.raw, null, 2));
        });

        content.querySelector('#view-root').addEventListener('click', () => {
            const display = content.querySelector('#root-json');
            display.textContent = JSON.stringify(blueprint.raw, null, 2);
            display.classList.toggle('visible');
            content.querySelector('#selected-json').classList.remove('visible');
        });

        content.querySelector('#download-root').addEventListener('click', () => {
            downloadJson(blueprint.raw, generateFilename(blueprint.raw, true));
        });

        if (selectedBlueprintPath) {
            content.querySelector('#copy-selected').addEventListener('click', () => {
                navigator.clipboard.writeText(JSON.stringify(selectedJson, null, 2));
            });

            content.querySelector('#view-selected').addEventListener('click', () => {
                const display = content.querySelector('#selected-json');
                display.textContent = JSON.stringify(selectedJson, null, 2);
                display.classList.toggle('visible');
                content.querySelector('#root-json').classList.remove('visible');
            });

            content.querySelector('#download-selected').addEventListener('click', () => {
                downloadJson(selectedJson, generateFilename(selectedJson, false, selectedBlueprintPath));
            });
        }

        cardElement.classList.add('expanded');
    }

    // Event listeners
    document.getElementById('blueprint-input').addEventListener('paste', (event) => {
        hideError();
        const blueprint = parseBlueprint(event.clipboardData.getData('text'));
        if (blueprint) {
            updateBasicInfo(blueprint);
            updateBlueprintTree(blueprint);
            updateSummary(blueprint);
            updateContents(blueprint);
            updateUpgradePlanner(blueprint);
            updateDeconstructionPlanner(blueprint);
            updateParameters(blueprint);
            updateJson(blueprint);
        }
    });

    // Card expansion handlers
    document.querySelectorAll('.card').forEach(card => {
        card.querySelector('.card-header').addEventListener('click', () => {
            card.classList.toggle('expanded');
        });
    });

    // Rich text parsing
    const richTextParser = {
      // Color name to RGB mapping for named colors
      colorMap: {
        'default': '#ffffff',
        'red': '#ff0000',
        'green': '#00ff00',
        'blue': '#0000ff',
        'orange': '#ffa500',
        'yellow': '#ffff00',
        'pink': '#ffc0cb',
        'purple': '#800080',
        'white': '#ffffff',
        'black': '#000000',
        'gray': '#808080',
        'brown': '#a52a2a',
        'cyan': '#00ffff',
        'acid': '#80ff00'
      },

      // Font mapping
      fontMap: {
        'default-bold': 'font-weight: bold;',
        'default-large': 'font-size: 120%;',
        'default-large-bold': 'font-size: 120%; font-weight: bold;'
      },

      // Parse a color value which could be named or RGB
      parseColor(color) {
        if (this.colorMap[color]) {
          return this.colorMap[color];
        }
        // Handle RGB format like "1,0,0" or "255,0,0"
        if (color.includes(',')) {
          const parts = color.split(',').map(Number);
          if (parts.length === 3) {
            if (Math.max(...parts) <= 1) {
              // Convert 0-1 range to 0-255
              parts = parts.map(n => Math.round(n * 255));
            }
            return `rgb(${parts.join(',')})`;
          }
        }
        // Handle hex colors
        if (color.startsWith('#')) {
          return color;
        }
        return this.colorMap.default;
      },

      // Convert game objects to icon images
      createIcon(type, name) {
        return `<img src="https://www.factorio.school/icons/${type}/${name}.png"
                     alt="${type}:${name}"
                     class="inline align-middle"
                     style="height: 1em;">`;
      },

      // Parse rich text markup into HTML
      parseRichText(text) {
        if (!text) return '';

        let result = text;

        // Replace game object references with icons
        const iconRegex = /\[(item|fluid|entity|technology|recipe|virtual-signal|achievement|tile)=([^\]]+)\]/g;
        result = result.replace(iconRegex, (_, type, name) => this.createIcon(type, name));

        // Handle GPS coordinates
        const gpsRegex = /\[gps=(-?[\d.]+),(-?[\d.]+)(?:,([^\]]+))?\]/g;
        result = result.replace(gpsRegex, (_, x, y, surface) => {
          const loc = surface ? `${surface} ${x},${y}` : `${x},${y}`;
          return `<span class="gps-coords">üìç ${loc}</span>`;
        });

        // Handle color tags
        const colorRegex = /\[color=([^\]]+)\](.*?)(?:\[\/color\]|\[\.color\])/gs;
        result = result.replace(colorRegex, (_, color, content) => {
          const parsedColor = this.parseColor(color);
          return `<span style="color: ${parsedColor}">${content}</span>`;
        });

        // Handle font tags
        const fontRegex = /\[font=([^\]]+)\](.*?)(?:\[\/font\]|\[\.font\])/gs;
        result = result.replace(fontRegex, (_, font, content) => {
          const style = this.fontMap[font] || '';
          return `<span style="${style}">${content}</span>`;
        });

        // Handle special item tags
        const specialRegex = /\[(special-item)=([^\]]+)\]/g;
        result = result.replace(specialRegex, (_, type, content) => {
          return `<span class="special-item">${content}</span>`;
        });

        // Handle train references
        const trainRegex = /\[train=(\d+)\]/g;
        result = result.replace(trainRegex, (_, number) => {
          return `<span class="train-ref">üöÇ ${number}</span>`;
        });

        // Handle train stop references
        const trainStopRegex = /\[train-stop=(\d+)\]/g;
        result = result.replace(trainStopRegex, (_, number) => {
          return `<span class="train-stop-ref">üöâ ${number}</span>`;
        });

        // Handle image tags
        const imgRegex = /\[img=([^\/\]]+)\/([^\]]+)\]/g;
        result = result.replace(imgRegex, (_, category, name) => {
          return this.createIcon(category, name);
        });

        return result;
      }
    };

    // Update display functions to use rich text parsing
    function displayRichText(text, element) {
      if (!text) {
        element.style.display = 'none';
        return;
      }
      element.style.display = 'block';
      element.innerHTML = richTextParser.parseRichText(text);
    }
</script>
</body>
</html>
